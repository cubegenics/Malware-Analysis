#!/usr/bin/env python
# coding: utf-8

# In[33]:


# # # ----------------------------------------------------------------------------------------------

# # # generate N transformations which would drive the IFS
# import random

# def generate_transformations(N):
#     transformations = []
#     for _ in range(N):
#         r = random.uniform(0.5, 1.5)  # Scaling factor
#         s = random.uniform(-0.2, 0.2)  # Shear factor
#         theta = random.uniform(0, 2 * 3.1416)  # Rotation angle
#         phi = random.uniform(0, 2 * 3.1416)  # Rotation angle
#         e = random.uniform(-1, 1)  # Translation in x-axis
#         f = random.uniform(-1, 1)  # Translation in y-axis
#         transformations.append((r, s, theta, phi, e, f))
#     return transformations

# # Generate N random transformations for N vertices
# N = 400
# transformations = generate_transformations(N)

# # Print the generated transformations
# for i, transform in enumerate(transformations, start=1):
#     print(f"Transformation {i}: {transform}")

# # write the transformations to a file
# import csv

# transformation_file_name = 'transformations.csv'

# with open(transformation_file_name, 'w', newline='') as csvfile:
#     csv_writer = csv.writer(csvfile)
#     csv_writer.writerows(transformations)

import csv

def read_csv_to_list(file_path):
    data = []
    with open(file_path, 'r') as file:
        csv_reader = csv.reader(file)
        for row in csv_reader:
            # Convert each element to a floating-point number
            row_float = [float(element) for element in row]
            data.append(row_float)
    return data

# Specify the path to your CSV file
file_path = 'transformations.csv'

# Call the function to read and convert the CSV file
transformations = read_csv_to_list(file_path)

# Print the result
# for i in range(len(transformations)):
#     print("Transformation {", i + 1,"}: ",transformations[i])




# In[34]:


# ----------------------------------------------------------------------------------------------

# driven ifs
import numpy as np
import matplotlib.pyplot as plt

# take driving sequence as input

# sequence_str = input("Enter a sequence of numbers from 1 to 4 (e.g., 12341432): ")
# input_sequence = [int(char) for char in sequence_str]

def polar_to_cartesian(r, theta):
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    return x, y

def transform_point(point, transformation):
    r, s, theta, phi, e, f = transformation
    x, y = point
    
    # Apply scaling
    x, y = x * r, y * s

    # Apply rotation
    x_rot, y_rot = polar_to_cartesian(np.sqrt(x**2 + y**2), np.arctan2(y, x) + theta)
    
    # Apply shearing
    x, y = x_rot + phi * y_rot, y_rot + phi * x_rot
    
    # Apply translation
    x, y = x + e, y + f
    
    return x, y


def plot_fractal(points, image_path_name):
    # Extract x and y coordinates for plotting
    x_coords, y_coords = zip(*points)
    
    # Plot the fractal
    bins = 200
    hist, xedges, yedges = np.histogram2d(x_coords, y_coords, bins=bins)

    fig, ax = plt.subplots()

    ax.scatter(x_coords, y_coords, alpha = 0.5)

    ax.axis('off')

    # plt.scatter(x_coords, y_coords, s=1, c='black', marker='.')

    # plt.axis('off')
    fig.set_dpi(100)
    fig.set_size_inches(2, 2)
    
    # plt.savefig(image_path_name, bbox_inches='tight', pad_inches=0)
    # fig.savefig(image_path_name, bbox_inches = 'tight', pad_inches = 0)

    # plt.show()


# In[35]:


# for only changing the input opcode sequence which generates the fractal plot,
# run all cells starting from this one, let the above ones stay the same,
# as each time you run the above ones, a new set of transformations would be generated

import matplotlib.pyplot as plt
import numpy as np
import sys
from pathlib import Path
import os

# ----------------------------------------------------------------------------------------------
# input file contains one opcode in each line
# this code converts the same to an integer sequence which would drive our IFS

def extract_file_name(absolute_path):
    # input: '~/Documents/malware/opcode_sequences/pu_stub_opcodes.txt'
    # output: 'pu_stub_opcodes.txt'
    return Path(absolute_path).name


absolute_file_path = sys.argv[1]
# absolute_file_path = '~/Documents/malware/opcode_sequences/pu_stub_opcodes.txt'

relative_file_path = "../opcode_sequences/" + extract_file_name(absolute_file_path)

file_name_with_ext = extract_file_name(absolute_file_path)
file_name_without_ext = file_name_with_ext.removesuffix(".txt")

#print("Absolute path:", absolute_file_path)
#print("Relative path:", relative_file_path)

#print(extract_file_name(absolute_file_path))

output_list = []

with open(relative_file_path, 'r') as file:
    for line in file:
        entry = line.strip()  # Remove leading/trailing whitespaces, if any
        output_list.append(entry)

output_list_set = set(output_list)
# # print(len(set(output_list)))
#         
item_to_number_mapping = {}
#
# for index, item in enumerate(output_list_set, start=1):
#     item_to_number_mapping[item] = index
#
#
# csv_file = 'mapping.csv'

# # # Write the dictionary to the CSV file
# # with open(csv_file, 'w', newline='') as file:
# #     writer = csv.writer(file)
#
# #     # Write each key-value pair on a separate line
# #     for key, value in item_to_number_mapping.items():
# #         writer.writerow([key, value])
#
# # print(f'Dictionary has been written to {csv_file}.')

mapping_file = 'mapping.csv'

# Read the CSV file into a dictionary
with open(mapping_file, 'r') as file:
    reader = csv.reader(file)

    for row in reader:
        # Assuming each row has two values separated by a comma
        key, value = row
        item_to_number_mapping[key.strip()] = int(value.strip())  # Convert the value to integer if needed



ifs_driving_sequence = []

for opcode in output_list:

    ifs_driving_sequence.append(item_to_number_mapping[opcode])

# print(item_to_number_mapping)
# print(output_list)
# print(ifs_driving_sequence)



# In[36]:


# what is the length of addresses we're plotting?
# e.x. 23432413, is it 3? 5? etc.
# if 3: 432, 343, etc.
# if 5: 23432, 42343, etc.
len_of_address = 500

addresses_to_plot = []
input_sequence = ifs_driving_sequence

# for _ in range(1000000):
#     num = random.randint(1, 3)
#     input_sequence.append(num)


total_number_of_addresses = len(input_sequence) - len_of_address + 1

percentage_variable = 1

for i in range(len(input_sequence)):

    if (i + len_of_address - 1 >= len(input_sequence)) :
        break
    
    cur_address = []
    for j in range(len_of_address - 1, -1, -1):
        #cur_address += ' ' + str(input_sequence[i + j])
        cur_address.append(input_sequence[i + j])

    percentage_complete = 100 * ((i + 1) / total_number_of_addresses)

    if (10 * percentage_variable == int(percentage_complete)):
        print(int(percentage_complete), "% completed generating addresses for file: ", file_name_without_ext)
        percentage_variable += 1
        if (percentage_variable == 11):
            print("\n")

    addresses_to_plot.append(cur_address)


# print(addresses_to_plot)


# In[38]:


# ----------------------------------------------------------------------------------------------
import os
    
new_fractal_points = []

def plot_fractal_with_address(transformations, address, resolution_limit):
    # Define the initial point
    point = np.array([0.5, 0.5])

    # Plot the initial point
    # plt.scatter(point[0], point[1], color='blue', s=5)
    #substrings = address.split()
    #address_int = [int(substring) for substring in substrings]

    for iteration in range(resolution_limit):
        # Get the index of the transformation from the address
        # transformation_index = int(address[iteration % len(address)])

        # Apply the chosen transformation to the point
        # point = apply_transform(point, transformations[transformation_index])

        index = address[iteration % len(address)] - 1
        transformation = transformations[index]

        # Apply the selected transformation to the current point
        point = transform_point(point, transformation)

        # Plot the current point
        # plt.scatter(point[0], point[1], color='black', s=5)

    new_fractal_points.append(point)
    # plt.title(f"Fractal with Address: {' '.join(map(str, address))}")
    # plt.show()

for address in addresses_to_plot:
    plot_fractal_with_address(transformations, address, len_of_address)
    
# plot_fractal_with_address(transformations, "012", 1000)

# image_name = "pu_stub_opcodes.txt"
image_name = file_name_without_ext
#print(image_name)
# image_name.removesuffix(".txt")
image_path_name = '../images/' + image_name + '.png'

# the path specified is relative with respect to the directory where the code is executed

plot_fractal(new_fractal_points, image_path_name)

# for address in addresses_to_plot:
#     print(address)

# for point in new_points:
#     print(point)


# In[ ]:


# ----------------------------------------------------------------------------------------------
# convert (x, y) coordinates to feature vector

sorted_points = sorted(new_fractal_points, key=lambda x: x[0])
feature_vector = []

for tuple_ in sorted_points:
    x = tuple_[0]
    feature_vector.append(x)

for tuple_ in sorted_points:
    y = tuple_[1]
    feature_vector.append(y)

# print(feature_vector)
print("Number of instructions for file", file_name_without_ext, ": ", len(output_list))
print("Length of feature vector for file", file_name_without_ext , ": ",len(feature_vector))

endline = 100 * '*'
print(endline, "\n\n")


def write_list_to_file(output_file_path, my_list):
    with open(output_file_path, 'w') as file:
        for item in my_list:
            file.write(str(item) + '\n')


# Example usage:
output_file_path = '../feature_vectors/' + file_name_without_ext + '_feature_vector.txt'

write_list_to_file(output_file_path, feature_vector)

# ----------------------------------------------------------------------------------------------

